---
layout: post
keywords: 设计模式, 面向对象六大基本原则, 软件设计原则
description: 设计模式系列学习记录,面向对象设计的六大基本原则
title: "设计模式之面向对象六大基本原则"
categories: [设计模式]
tags: [设计模式, 六大基本原则]
group: archive
icon: file-alt
---
{% include site/setup %}

<hr>
##**综述**

在运用面向对象的思想进行软件设计时，需要遵循的原则一共有6个，他们是：

1. 单一职责原则（Single Responsibility Principle）
2. 里氏替换原则（Liskov Substitution Principle）
3. 依赖倒置原则（Dependence Inversion Principle）
4. 接口隔离原则（Interface Segregation Principle）
5. 迪米特法则（Law Of Demeter）
6. 开闭原则（Open Close Principle）

<hr>

##**详情分析**

**单一职责原则（Single Responsibility Principle）**

单一职责原则：

消除耦合，减小因需求变化引起代码僵化。

对于一个类来说，应该只专注于做一件事和仅有一个引起它变化的原因。
所谓职责，我们可以理解他为功能，就是设计的这个类功能应该只有一个，而不是两个或更多。
也可以理解为引用变化的原因，当你发现有两个变化会要求我们修改这个类，那么你就要考虑撤分这个类了。

因为：

类A负责两个不同的职责：职责B1，职责B2。当由于职责B1需求发生改变而需要修改类A时，
有可能会导致原本运行正常的职责B2功能发生故障。

类A只负责一个职责B，后来由于某种原因要将职责B细分为职责B1，B2，这时如果要使程序遵循单一职责原则，
需要将类A也分解为两个类A1和A2，分别负责B1、B2两个职责。但是在程序已经写好的情况下，这样做太费时间。
所以，简单的修改类A，用它来负责两个职责。这样做有悖于单一职责原则，但是在一些修改中是值得取舍的。

所以：

建立两个类A1、A2，使A1完成职责B1功能，A2完成职责B2的功能。



1、一个合理的类，应该仅有一个引起它变化的原因，即单一职责；
2、在没有变化征兆的情况下应用单一职责原则或其他原则是不明智的；
3、在需求实际发生变化时就应该应用单一职责原则等原则来重构代码；
4、使用测试用例开发时会迫使我们在设计跑题之前分离出来不合理代码；
5、如果测试不能迫使职责分离，僵化性和脆弱性的的代码会越来越多，那就应该用其他模式对代码重构；

二、里氏代换原则
全称：“Liskov Substitution Principle”
说明：子类型必须能够替换它们的基类型。一个软件实体如果使用的是一个基类，那么当把这个基类替换成继承该基类的子类，程序的行为不会发生任何变化。软件实体察觉不出基类对象和子类对象的区别。
优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。
三、依赖倒置原则
全称：“Dependence Inversion Principle”
说明：要依赖于抽象，不要依赖于具体。客户端依赖于抽象耦合。
抽象不应当依赖于细节；细节应当依赖于抽象；
要针对接口编程，不针对实现编程。
优点：使用传统过程化程序设计所创建的依赖关系，策略依赖于细节，这是糟糕的，因为策略受到细节改变的影响。依赖倒置原则使细节和策略都依赖于抽象，抽象的稳定性决定了系统的稳定性。
怎样做到依赖倒置？
以抽象方式耦合是依赖倒转原则的关键。抽象耦合关系总要涉及具体类从抽象类继承，并且需要保证在任何引用到基类的地方都可以改换成其子类，因此，里氏代换原则是依赖倒转原则的基础。
在抽象层次上的耦合虽然有灵活性，但也带来了额外的复杂性，如果一个具体类发生变化的可能性非常小，那么抽象耦合能发挥的好处便十分有限，这时可以用具体耦合反而会更好。
层次化：所有结构良好的面向对象构架都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供一组内聚的服务。
依赖于抽象：建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接口。尽量做到：
1、任何变量都不应该持有一个指向具体类的指针或者引用。
2、任何类都不应该从具体类派生。
3、任何方法都不应该覆写它的任何基类中的已经实现的方法。
四、接口隔离原则
全称：“Interface Segregation Principle”
说明：使用多个专一功能的接口比使用一个的总接口总要好。从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。过于臃肿的接口是对接口的污染，不应该强迫客户依赖于它们不用的方法。
优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。
如何实现接口隔离原则
不应该强迫用户依赖于他们不用的方法。
1、利用委托分离接口。
2、利用多继承分离接口。
五、迪米特原则
全称：“Law of Demeter”
说明：对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系。
如何实现迪米特法则？
迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点：
1) 在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。
2) 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。
3) 在类的设计上，只要有可能，一个类应当设计成不变类。
4) 在对其它对象的引用上，一个类对其它对象的引用应该降到最低。
六、开放－封闭原则
全称：“Open-Closed Principle”
说明：对扩展开放，对修改关闭。
优点：按照OCP原则设计出来的系统，降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响或影响很小，这样就无须为原有模块进行重新测试。
如何实现“开-闭”原则？
在面向对象设计中，不允许更改的是系统的抽象层，而允许扩展的是系统的实现层。换言之，定义一个一劳永逸的抽象设计层，允许尽可能多的行为在实现层被实现。
解决问题关键在于抽象化，抽象化是面向对象设计的第一个核心本质。
对一个事物抽象化，实质上是在概括归纳总结它的本质。抽象让我们抓住最最重要的东西，从更高一层去思考。这降低了思考的复杂度，我们不用同时考虑那么多的东西。换言之，我们封装了事物的本质，看不到任何细节。
在面向对象编程中，通过抽象类及接口，规定了具体类的特征作为抽象层，相对稳定，不需更改，从而满足“对修改关闭”；而从抽象类导出的具体类可以改变系统的行为，从而满足“对扩展开放”。
对实体进行扩展时，不必改动软件的源代码或者二进制代码。关键在于抽象。



1) 开闭原则: 
    即面向扩展开放，面向修改封闭，也就是说系统支持扩展，但是不支持修改。
    为什么这么做？
在开发阶段，我们都知道，如果对一个功能进行扩展，如果只是一味地对方法进行修改，可能会造成一些问题，诸如 可 能会引入新的bug，或者增加代码的复杂度，对代码结构造成破坏、冗余，还需要重新进行全面的测试。那么该怎么解决这些问题？很简单，这就需要系统能够支持扩展，只有扩展性良好的系统，才能在不进行修改已有实现代码的基础上，引进新的功能。
 
    我们应该怎么做？
要做到开闭原则，就需要多使用抽象类或者接口，将相似的类进行抽象，将公有的功能引入到抽象类中，这样在进行扩展时，只需要依据抽象类，生成新的子类即可。
 
2) 里氏代换原则:
    即任何使用基类的地方，都能够使用子类替换，而且在替换子类后，系统能够正常工作。
    为什么这么做？
采用里氏替代原则可以增强程序的健壮性，版本升级的时候可以保持非常好的兼容性，即使增加子类，原有的子类也可以继续运行。
    我们应该怎么做？
在引用基类的地方就能引用子类实现
 
 
3) 依赖倒转原则:
    即我们的client类要依赖于抽象，而不是依赖于具体，也就是我们经常听到的“要面向接口编程”。
    为什么这么做？
减少类间的耦合性，提高代码的可读性和可维护性。
    我们应该怎么做？
a、每个类尽量都有接口和抽象类，或者抽象类和接口都有。
b、变量的表面类型尽量是接口或者是抽象类。
c、任何类都不应该从具体类派生。（但是在做二次开发的时候，我们无法获得高层代码的时候例外），规则不是绝对的。
d、尽量不要覆写基类已经实现好的方法。
 
4) 接口隔离原则:
     即应该将接口粒度最小化，将功能划分到每一个不能再分的子角色，为每一个子角色创建接口，通过这样，才不会让接口的实现类实现一些不必要的功能。
    为什么这么做？
避免让接口的实现类实现一些不必要的功能
    我们应该怎么做？
建立单一的接口，不要建立臃肿的庞大的接口，也就是说接口的方法尽量少。
 
5) 迪米特法则:
    即尽量减少类之间的依赖关系.
    为什么这么做？
       降低类之间的耦合。
    我们应该怎么做？
       在应用中最直接的实现就是在两个类中间建一个中介类。但是这样可能会造成中介类的澎爆。
 
6) 合成/聚合复用原则:
    即少用继承，多用组合。
    为什么这么做？
优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。
    我们应该怎么做？
使用组合也就是将两个类之间建立关联关系，将一个类做为另一个类的属性。
继承与组合主要是区分两个角色之间是"is a"还是"has a"的关系，如果是"is a"就需要使用继承，而如果是"has a"就需要使用组合。
例如笔可以分为钢笔和油笔，这就是is a的关系，但是油笔与笔芯就是has a的关系。

<hr>

{% highlight ruby %}

{% endhighlight %}


{% highlight ruby %}

{% endhighlight %}
