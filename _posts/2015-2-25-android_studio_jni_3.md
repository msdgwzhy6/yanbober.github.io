---
layout: post
keywords: jni, Android Studio, ndk
description: Android Studio NDK, Android Studio JNI, JNI, NDK
title: "NDK-JNI实战教程（三） 从一个比Hello World稍微复杂一丁点儿的例子说说模板"
categories: [NDK-JNI开发]
tags: [NDK, JNI]
group: archive
icon: file-alt
---
{% include site/setup %}

<hr>

##概述

学习JNI NDK你需要有java与C或者C++基础。因为NDK几乎就是java与C或者C++的混合编程互调，JNI在其中只是扮演了一个不同语种间对接握手调运的规则而已。
就像C语言嵌入调运执行汇编程序一样，需要一种规则来约束沟通。这个例子是我在闲时继续使用Android Studio撸的，不难，适合入门。
不要一下子被这么几个文件吓着了。重点是为了通过这个例子引出来几个Android NDK开发的重要基础模板知识点。
所以内在代码逻辑看上去可能十分僵硬不合理，代码风格可能也不是十分规范，还请多多指点交流，然后撸的更多。

这篇文章想了想还是先上结构和源码，然后后面分析内容。

<hr>

##代码及工程文件介绍

这是这篇文章要介绍的代码工程的几个主要文件夹文件分布情况：

<img src="http://yanbober.github.io/image/2015-2-14-android_studio_jni_1/4.png" />

io.github.yanbober.ndkapplication包中MainActivity主Activity代码：

{% highlight ruby %}

package io.github.yanbober.ndkapplication;

import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;
import android.widget.TextView;

public class MainActivity extends ActionBarActivity {
    private TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mTextView = (TextView) this.findViewById(R.id.test);

        NdkJniUtils jni = new NdkJniUtils();
        //传入name="vip"到jni代码模拟拿到加密后的key
        mTextView.setText(jni.generateKey("vip"));
    }
}
	
{% endhighlight %}

io.github.yanbober.ndkapplication包中NdkJniUtils类代码：

{% highlight ruby %}

package io.github.yanbober.ndkapplication;

public class NdkJniUtils {
    public native String generateKey(String name);

    static {
        System.loadLibrary("YanboberJniLibName");
    }
}
		
{% endhighlight %}

jni根目录下通过系列教程一中javah生成的头文件io_github_yanbober_ndkapplication_NdkJniUtils.h内容：

{% highlight ruby %}

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>

#ifndef _Included_io_github_yanbober_ndkapplication_NdkJniUtils
#define _Included_io_github_yanbober_ndkapplication_NdkJniUtils
#ifdef __cplusplus
extern "C" {
#endif

JNIEXPORT jstring JNICALL Java_io_github_yanbober_ndkapplication_NdkJniUtils_generateKey(JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
	
{% endhighlight %}

jni根目录下通过系列教程一中类似test生成的jni接口c文件jni_interface.c内容：

{% highlight ruby %}

#include <jni.h>
#include <string.h>
#include "io_github_yanbober_ndkapplication_NdkJniUtils.h"
#include "./utils/android_log_print.h"
#include "./local_logic_c/easy_encrypt.h"

JNIEXPORT jstring JNICALL Java_io_github_yanbober_ndkapplication_NdkJniUtils_generateKey
  (JNIEnv *env, jobject obj, jstring name){
     //声明局部量
     char key[KEY_SIZE] = {0};
     memset(key, 0, sizeof(key));

     char temp[KEY_NAME_SIZE] = {0};

     //将java传入的name转换为本地utf的char*
     const char* pName = (*env)->GetStringUTFChars(env, name, NULL);

     if (NULL != pName) {
        strcpy(temp, pName);
        strcpy(key, generateKeyRAS(temp));

        //java的name对象不需要再使用，通知虚拟机回收name
        (*env)->ReleaseStringUTFChars(env, name, pName);
     }

     return (*env)->NewStringUTF(env, key);
  }	
	
{% endhighlight %}

jni目录下utils子目录下的log打印工具宏android_log_print.h文件内容：

{% highlight ruby %}

/*
 * 作者：工匠若水
 * 说明：Android JNI Log打印宏定义文件
 */

#ifndef _ANDROID_LOG_PRINT_H_
#define _ANDROID_LOG_PRINT_H_

#include <android/log.h>

#define IS_DEBUG

#ifdef IS_DEBUG

#define LOG_TAG ("CUSTOMER_NDK_JNI")

#define LOGV(...) ((void)__android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__))

#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG  , LOG_TAG, __VA_ARGS__))

#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO   , LOG_TAG, __VA_ARGS__))

#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN   , LOG_TAG, __VA_ARGS__))

#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR  , LOG_TAG, __VA_ARGS__))

#else

#define LOGV(LOG_TAG, ...) NULL

#define LOGD(LOG_TAG, ...) NULL

#define LOGI(LOG_TAG, ...) NULL

#define LOGW(LOG_TAG, ...) NULL

#define LOGE(LOG_TAG, ...) NULL

#endif

#endif
		
{% endhighlight %}

jni目录下local_logic_c本地C语言实现的逻辑目录下的接口头文件easy_encrypt.h内容：

{% highlight ruby %}

#ifndef _EASY_ENCRYPT_H_
#define _EASY_ENCRYPT_H_
/*
 * 作者：晏博
 *
 * 功能：通过name获取加密后的key
 * 类型：测试代码
 */
#define KEY_NAME_SIZE  (6)
#define KEY_SIZE  (129)

char* generateKeyRAS(char* name);

#endif /* _EASY_ENCRYPT_H_ */
		
{% endhighlight %}

jni目录下local_logic_c本地C语言实现的逻辑目录下的接口逻辑实现文件easy_encrypt.c内容：

{% highlight ruby %}

#include <string.h>
#include "easy_encrypt.h"
#include "./../utils/android_log_print.h"

/*
 * 功能：通过传入name生成加密后唯一的key值
 *
 * name 传入小于KEY_NAME_SIZE的字符串
 * return 通过name生成的验证key值
 */
char* generateKeyRAS(char* name)
{
    //判断形参是否有效
    if (NULL == name || strlen(name) > KEY_NAME_SIZE) {
//        printf("function generateKey must have a ok name!\n");
        return NULL;
    }

    //声明局部变量
    int index = 0;
    int loop = 0;
    char temp[KEY_SIZE] = {"\0"};
    //清空数组内存
    memset(temp, 0, sizeof(temp));
    //将传进来的name拷贝到零时空间
    strcpy(temp, name);
    //进行通过name转化生成key的逻辑，这里是模拟测试，实际算法比这复杂
    for (index=0; index<KEY_SIZE-1; index++)
    {
        temp[index] = 93;
        LOGD("---------------temp[%d]=%c", index, temp[index]);
    }

    return temp;
}

{% endhighlight %}

<hr>

##基本分析



##总结

	（烦请令尊体谅作者劳动成果，转载麻烦声明文章链接。您的声明与讨论是鄙人写作的动力。JNI NDK系列文章依据时间及个人情况持续更新中......）
