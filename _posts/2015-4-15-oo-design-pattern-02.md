---
layout: post
keywords: 设计模式, 面向对象基本原则, 七大原则
description: 设计模式系列学习记录
title: "设计模式之面向对象七大基本原则"
categories: [设计模式]
tags: [设计模式, 基本原则]
group: archive
icon: file-alt
---
{% include site/setup %}

<hr>

##**概述**

在运用面向对象的思想进行软件设计时，需要遵循的原则一共有7个，他们是：

**1. 单一职责原则（Single Responsibility Principle）**

每一个类应该专注于做一件事情。

**2. 里氏替换原则（Liskov Substitution Principle）**

超类存在的地方，子类是可以替换的。

**3. 依赖倒置原则（Dependence Inversion Principle）**

实现尽量依赖抽象，不依赖具体实现。

**4. 接口隔离原则（Interface Segregation Principle）**

应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。

**5. 迪米特法则（Law Of Demeter）**

又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。

**6. 开闭原则（Open Close Principle）**

面向扩展开放，面向修改关闭。

**7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）**

尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。

<hr>

##**细则**

**单一职责原则（Single Responsibility Principle）**

因为：

可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；
提高类的可读性，提高系统的可维护性；
变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。
需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。

所以：

从大局上看Android中的Paint和Canvas等类都遵守单一职责原则，Paint和Canvas各司其职。

**里氏替换原则（Liskov Substitution Principle）**

因为：

里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，
反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。
里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，
因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

所以：

使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，
并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。

从大局看Java的多态就属于这个原则。

**依赖倒置原则（Dependence Inversion Principle）**

因为：

具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，
这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；
这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。
通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。

所以：

采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。

从大局看Java的多态就属于这个原则。

**接口隔离原则（Interface Segregation Principle）**

因为：

提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。
譬如类ProgramMonkey通过接口CodeInterface依赖类CodeC，类ProgramMaster通过接口CodeInterface依赖类CodeAndroid，
如果接口CodeInterface对于类ProgramMonkey和类CodeC来说不是最小接口，则类CodeC和类CodeAndroid必须去实现他们不需要的方法。
将臃肿的接口CodeInterface拆分为独立的几个接口，类ProgramMonkey和类ProgramMaster分别与他们需要的接口建立依赖关系。
也就是采用接口隔离原则。

所以：

建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。
也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，
通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。

从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。

**迪米特法则（Law Of Demeter）**

因为：


所以：

{% highlight ruby %}

{% endhighlight %}

